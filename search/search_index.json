{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#about","title":"About","text":"<p>Welcome to the phylojs documentation! The phylojs repo can be found at https://github.com/clockor2/phylojs. </p> <p>Phylojs is a javascript and typescript library for reading, writing, and manipulating phylogenetic trees. It is intended as a utility library to manipulate trees from input and before visualisation.</p> <p>Phylojs is a small library with zerio-dependencies. It has 3 functions for reading and writing trees. It also includes two classes: nodes and trees, with the tree object a nesting of nodes. All the rest of the functionality included as methods on both classes, which these docs describe. There are also some examples of using phylojs.</p>"},{"location":"cite/","title":"Cite","text":""},{"location":"cite/#cite-phylojs","title":"Cite phylojs","text":"<p>If you use phylojs in your work, please consider citing Featherstone et al., 2023.</p> <p>Info</p> <p>Citation on the way...</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#examples","title":"Examples","text":"<p>The following is a series of examples demonstrating how phylojs might be used in practice.</p>"},{"location":"examples/annotations/","title":"Working with annotations","text":""},{"location":"examples/annotations/#handling-annotations","title":"Handling annotations","text":"<p>All node objects have an <code>annotation</code> field where annotations. The <code>annotation</code> fiel itself stores an object for all annotated tags. For example <code>Node.annotations = {Type: Blue}</code> for some leaf nodes in the following example.</p> <p>Here, we show show how annotations can be extracted and modified in a loop. We swap Blue an Green type annotations to Red and Yellow on a small tree.</p> <p>Altered annotations are then writtedn back to newick or nexus.</p> <pre><code>        let newick = '((A[&amp;Type=Blue],B[&amp;Type=Blue]),C[&amp;Type=Green]);'\n        let tree = readNewick(newick)\n\n        if (tree.leafList !== undefined) { // Avoids 'leafList' possibly undefined error\n\n            for (let i=0; i&lt;tree.leafList.length; i++) {\n                if(tree.leafList[i].annotation.Type == 'Blue') {\n                    tree.leafList[i].annotation.Type = 'Red'\n                } else {\n                    tree.leafList[i].annotation.Type = 'Yellow'\n                }\n            }\n        }\n\n        console.log(writeNewick(tree, true))\n        // ((\"A\"[&amp;\"Type\"=\"Red\"]:0.0,\"B\"[&amp;\"Type\"=\"Red\"]:0.0):0.0,\"C\"[&amp;\"Type\"=\"Yellow\"]:0.0):0.0;\n        // Note types changed ^\n</code></pre>"},{"location":"examples/fetch/","title":"Fetching Trees fron a URL","text":"<p>Here, we demonstrate how to read in a tree from a url using a <code>fetch()</code> request from the fetch API. In this case, we are reading in a list of trees used for testing.</p> <pre><code>    let url = 'https://raw.githubusercontent.com/clockor2/phylojs/main/test/data/egTree.nwk'\n    let newick;\n\n    fetch(url)\n      .then(res =&gt; res.text())\n      .then(txt =&gt; {newick = txt})\n\n    // log first 99 characters to show newick is defined\n    console.log(newick.slice(0,99))\n    // Returns:\n    // (Jeddah-1_KF917527_camel_2013-11-08:0.0000013865,Jeddah-1_KF958702_human_2013-11-05:0.0000013652,((\n</code></pre>"},{"location":"examples/ieRatio/","title":"Summary statistics","text":"<p>Here, we demonstrate how we can caluclate a tree summary statistic at each internal node of a tree. We calculate the internal to external branch length ratio for the subtree descending from each internal node and add it as an annotation to each node. We define a function to calculate the internal to external branch length ratio <code>getBranchLengthRatio()</code> as well as demonstrate use of the <code>.isLeaf()</code> and <code>.applyPreOrder()</code> methods on the <code>Node</code> class.</p> <p>The internal to external branch length ratio is defined as the ratio of the sum of internal branch lenghts to the sum of external branch lengths (leading to tips). It is a commonly used statistic that describes how 'tippy' or 'stemmy' trees appear.</p> <pre><code>// Internal to external branch length ratio\n    function getBranchLengthRatio(tree: Tree): number {\n\n      let sumInternal: number = 0.0;\n      let sumExternal: number = 0.0;\n\n      for (let i=0; i&lt;tree.nodeList.length; i++) {\n        if(tree.nodeList[i].branchLength !== undefined){\n          if (tree.nodeList[i].isLeaf()) {\n            sumExternal += tree.nodeList[i].branchLength\n          } else {\n            sumInternal += tree.nodeList[i].branchLength\n          }\n        }\n      }\n      return sumInternal / sumExternal;\n    }\n\n    let nwk = `((a:2,b:2):1,(c:1,d:1):4);`\n    let tree = readNewick(nwk)\n\n    // IE ratio for subtrees descending from each node, except tips\n    tree.root.applyPreOrder((node: Node) =&gt; {\n      if(!node.isLeaf()) {\n        let ieRatio = getBranchLengthRatio(tree.getSubtree(node))\n        node.annotation = {ieRatio: ieRatio.toFixed(2)}\n      }\n    });\n\n    // Expect annotations in newick with `true` flag\n    console.log(writeNewick(tree, true))\n    // Returns:\n    // ((\"a\":2,\"b\":2)[&amp;\"ieRatio\"=\"0.25\"]:1,(\"c\":1,\"d\":1)[&amp;\"ieRatio\"=\"2.00\"]:4)[\"ieRatio\"=\"0.83\"]:0.0;\n</code></pre>"},{"location":"examples/mrca/","title":"Finding the MRCA","text":""},{"location":"examples/mrca/#finding-mrca-for-a-set-of-nodes","title":"Finding MRCA for a set of nodes","text":"<p>This script demonstrates how the <code>getNodeByLabel</code>, <code>getMRCA</code>, and <code>getSubtree</code> methods on the <code>Tree</code> object can be wrapped in a function to find and extract subtrees given a newick string and list of desired taxa.</p> <pre><code>import { readNewick, Tree, Node } from 'phylojs';\n\nfunction findMRCAandExtractSubtree(newickStr: string, labels: string[]): Tree {\n  const tree: Tree = readNewick(newickStr);\n  const nodes: Node[] = labels.map(label =&gt; {\n    const node = tree.getNodeByLabel(label);\n    if (node === null) throw new Error(`No node found with label ${label}`);\n    return node;\n  });\n\n  const mrca = tree.getMRCA(nodes);\n  if (mrca === null) throw new Error('MRCA is null');\n\n  const subtree: Tree = tree.getSubtree(mrca);\n\n  return subtree;\n}\n\nconst newickStr: string = '((A:0.1,B:0.2):0.3,(C:0.3,D:0.4):0.5,E:0.6);'; // Newick string as input\nconst labels: string[] = ['A', 'B', 'D']; // Leaf labels to find MRCA\n\ntry {\n  const subtree: Tree = findMRCAandExtractSubtree(newickStr, labels);\n  // Process the 'subtree' as needed\n  // For example, you might print it to the console\n  // console.log(subtree);\n} catch (error) {\n  console.error(error);\n}\n</code></pre>"},{"location":"examples/pruneGraft/","title":"Pruning and Grafting","text":"<p>Here we demonstrate pruning and grafting of nodes usig the <code>.addChild()</code> and <code>.removeChild()</code> methods on the <code>Node</code> class. In effect, these can be used to add or remove clades and tips.</p> <p>As a general node, using the <code>.copy()</code> method produces a deep copy of a node, and so is useful to avoid recursion issues with continual grafting.</p>"},{"location":"examples/pruneGraft/#pruning","title":"Pruning","text":"<pre><code>    let nwk = \"((A,B),(C,D));\"\n    let tree = readNewick(nwk)  \n\n    // Get ancestor of tips A and B\n    let node = tree.getMRCA(tree.leafList.slice(0,2))\n    // Prune\n    tree\n      .nodeList[node.parent.id] // Select node's parent by `id`\n      .removeChild(node) // Pruning step\n\n    console.log(`\n      Original Nwk: ${nwk}\n      Pruned Tree: ${writeNewick(tree)}\n    `)\n    // Returns\n    // Original Nwk: ((A,B),(C,D));\n    // Pruned Tree: ((\"C\":0.0,\"D\":0.0):0.0):0.0;\n</code></pre>"},{"location":"examples/pruneGraft/#grafting","title":"Grafting","text":"<pre><code>    let nwk = \"((A,B),(C,D));\"\n    let tree = readNewick(nwk)  \n\n    // Get ancestor of tips A and B. NB this is a `cherry` (A,B)\n    let node = tree.getMRCA(tree.leafList.slice(0,2))\n\n    // Graft cherry onto tip `A` 2 times to make a ladder.\n    for (let i=0; i&lt;2; i++) {\n      tree\n        //.nodeList[node.parent.id] // Select node's parent by `id`\n        .leafList[i]\n        .addChild(node.copy()) // .copy() to ensure we don't bump into recursion issues\n    }\n\n    console.log(`\n      Original Nwk: ${nwk}\n      Pruned Tree: ${writeNewick(tree)}\n    `)\n    // Return\n    // Original Nwk: ((A,B),(C,D));\n    // Pruned Tree: ((((\"A\":0.0,\"B\":0.0):0.0)\"A\":0.0,((((\"A\":0.0,\"B\":0.0):0.0)\"A\":0.0,\"B\":0.0):0.0)\"B\":0.0):0.0,(\"C\":0.0,\"D\":0.0):0.0):0.0;\n</code></pre>"},{"location":"examples/reroot/","title":"Rerooting","text":""},{"location":"examples/reroot/#rerooting-and-ladderising","title":"Rerooting and ladderising","text":"<p>In this example we will reroot at each node of a dummy tree and check that the tree length (the sum of all branch lengths) is identical each time.</p> <p>This example demonstrates use of the <code>.reroot</code>, <code>.nodeList</code>, and <code>.getTotalBranchLength()</code> methods.</p> <p>Node that <code>.nodeList</code> returns an array of nodes (<code>Node[]</code>), the first of which is always the root. <code>.reroot()</code> throws an error if you try to reroot at the root, which is why we start out loop from the 1st rather than 0th node below.</p> <pre><code>        let newick = '((\"D_2000\":1.0,\"E_2003\":1.2):3.0,(\"C_2005\":2.5,(\"A_2010\":1.8,\"B_2011\":1.07):1.0):1.2):4.0;'\n        let tree = readNewick(newick)\n\n        let nodes = tree.nodeList\n\n        let length: number[] = []\n        // Note i starts at 1 as 0th node is the root\n        for (let i=1; i&lt;nodes.length; i++) {\n\n            tree.reroot(nodes[i])\n            tree.ladderise()  // ladderising should also preserve length\n\n            length.push(tree.getTotalBranchLength())\n\n        }\n\n        console.log(`\n            legnth: ${length.map(e =&gt; e.toFixed(3))}\n        `)\n        // Returns:\n        // legnth: 12.770,12.770,12.770,12.770,12.770,12.770,12.770,12.770\n</code></pre>"},{"location":"examples/rttr/","title":"Root-to-tip regression","text":""},{"location":"examples/rttr/#root-to-tip-regression","title":"Root-to-tip Regression","text":"<p>In this example we will do a root to tip regression on a small tree.</p> <p>We will demonstrate use of <code>Tree.getRTTDist()</code>, <code>Tree.getTipLabels()</code>, and the <code>readNewick()</code> function. </p> <p>We begin by defining the newick string, the linear regression function, and a utility function to parse the tip date from the tip label:</p> <pre><code>    import { Tree, readNewick, writeNewick } from 'phylojs'\n\n    // Define tree with dates in tip labels\n    let newick = '((\"D_2000\":1.0,\"E_2003\":1.2):3.0,(\"C_2005\":2.5,(\"A_2010\":1.8,\"B_2011\":1.07):1.0):1.2):4.0;'\n\n    // Define utility functions to parse dates and do regression\n    interface LinearRegression {\n        x: number[],\n        y: number[],\n        fitY: number[],\n        slope: number,\n        intercept: number,\n        r2: number\n    }\n    function linearRegression(x: number[], y: number[]): LinearRegression {\n\n        let reg = {} as LinearRegression;\n\n        let sum_x = 0;\n        let n = y.length;\n        let sum_y = 0;\n        let sum_xy = 0;\n        let sum_xx = 0;\n        let sum_yy = 0;\n\n        for (let j = 0; j &lt; y.length; j++) {\n            sum_x += x[j];\n            sum_y += y[j];\n            sum_xy += (x[j]*y[j]);\n            sum_xx += (x[j]*x[j]);\n            sum_yy += (y[j]*y[j]);\n        } \n\n        reg.x = x;\n        reg.y = y;\n        reg.slope = (n * sum_xy - sum_x * sum_y) / (n*sum_xx - sum_x * sum_x);\n        reg.intercept = (sum_y - reg.slope * sum_x)/n;\n        reg.fitY = x.map(e =&gt; (reg.slope * e + reg.intercept));\n        reg.r2 = Math.pow((n*sum_xy - sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);\n\n        return reg;\n    }\n    function extractDate(name: string | undefined, delimiter: string, location: number): number {\n        return name !== undefined\n            ? parseFloat(name.split(delimiter)[location])\n            : NaN\n    }\n</code></pre> <p>Now we can run the regression and view the output </p><pre><code>    // read tree\n    let tree = readNewick(newick);\n\n    // get root-to-tip distances\n    let rttd = tree.getRTTDist()\n\n    // get dates\n    let dates = tree\n        .getTipLabels()\n        .map(e =&gt; extractDate(e, '_', 1))\n\n    // NB, you might need to disable linting for this line in VScode, as we have below!\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    let reg = linearRegression(dates, rttd)\n\n    // Do regression\n    console.log(reg)\n    // Returns\n    // {\n    //   x: [ 2000, 2003, 2005, 2010, 2011 ],\n    //   y: [ 4, 4.2, 3.7, 4, 3.2700000000000005 ],\n    //   slope: -0.04741935483868017,\n    //   intercept: 98.94774193542469,\n    //   fitY: [\n    //     4.109032258064346,\n    //     3.9667741935483036,\n    //     3.871935483870942,\n    //     3.6348387096775383,\n    //     3.5874193548388575\n    //   ],\n    //   r2: 0.37168278586966874\n    // }\n</code></pre>"},{"location":"examples/tree/","title":"Overview of the Tree Class","text":""},{"location":"examples/tree/#manipulate-trees","title":"Manipulate Trees","text":"<p>The Tree class in the provided code is a fundamental structure for storing and managing phylogenetic trees. It includes methods for manipulating and accessing information about the tree.</p>"},{"location":"examples/tree/#importing-the-class","title":"Importing the class","text":"<p>This class is exported from a module. You can import it into your code as follows:</p> <pre><code>import { Tree } from '../src/Tree';\n</code></pre>"},{"location":"examples/tree/#class-instantiation","title":"Class instantiation","text":"<p>A Tree object is created by providing a Node object (representing the root of the tree) to the Tree constructor:</p> <pre><code>const rootNode = new Node(0);\nconst tree = new Tree(rootNode);\n</code></pre>"},{"location":"examples/tree/#class-methods","title":"Class methods","text":"<p>Here are the key methods for the Tree class:</p> <ul> <li> <p><code>reroot(node, prop)</code>: Re-roots the tree at the specified node. Optionally, a proportion can be specified to position the root along the branch leading to the node.</p> </li> <li> <p><code>getTotalBranchLength()</code>: Returns the total sum of the lengths of all branches in the tree.</p> </li> <li> <p><code>getRTTDist()</code>: Returns an array of root-to-tip distances for all leaves in the tree.</p> </li> <li> <p><code>getSubtree(node)</code>: Returns a new Tree object representing the subtree rooted at the specified node.</p> </li> <li> <p><code>getMRCA(nodes)</code>: Returns the most recent common ancestor (MRCA) of the given list of nodes.</p> </li> <li> <p><code>getTipLabels()</code>: Returns an array of labels of all leaf nodes in the tree.</p> </li> <li> <p><code>nodeList()</code>: Returns an array of all nodes in the tree.</p> </li> <li> <p><code>leafList()</code>: Returns an array of all leaf nodes in the tree.</p> </li> </ul>"},{"location":"examples/tree/#function-usage","title":"Function usage","text":"<p>Below is a simple usage of the Tree class methods:</p> <pre><code>const rootNode = new Node(0);\nconst tree = new Tree(rootNode);\n\n// Access nodes\nconst nodes = tree.nodeList;\n\n// Reroot the tree at the second node\ntree.reroot(nodes[1]);\n\n// Get total branch length\nconst totalBranchLength = tree.getTotalBranchLength();\n\n// Get root-to-tip distances\nconst rttDist = tree.getRTTDist();\n\n// Get subtree\nconst subtree = tree.getSubtree(nodes[1]);\n\n// Get most recent common ancestor of two nodes\nconst mrca = tree.getMRCA([nodes[1], nodes[2]]);\n\n// Get tip labels\nconst tipLabels = tree.getTipLabels();\n</code></pre> <p>The Tree class is essential for various phylogenetic applications including tree manipulation, tree metrics calculation, and tree traversal. It works together with the Node class, where each node represents a vertex in the tree. Both classes are designed to be versatile and easy to use, catering to both simple and complex phylogenetic tree applications.</p>"},{"location":"examples/tree/#testing-the-class-methods","title":"Testing the Class Methods","text":"<p>The codebase includes a series of tests to verify the functionality of the Tree class. For instance, it tests rerooting, subtree extraction, and other operations. These tests ensure that the Tree class methods behave as expected when applied to a variety of tree structures.</p> <p>Ensure to run these tests after any modifications to the Tree class to ensure its integrity. The provided tests can be a helpful guide for extending the class with new features or for developing similar tests in the future for newly added methods.</p>"},{"location":"examples/treeArray/","title":"Working with arrays of trees","text":""},{"location":"examples/treeArray/#working-with-arrays-of-trees","title":"Working with arrays of trees","text":"<p>This examples demonstrates how once can manipulate an array of trees for efficient bulk processing.</p> <p>Arrays of trees (<code>Tree[]</code>) can be read in with any of the <code>readTrees*()</code> functions. That is, <code>readTreesFromNewick()</code>, <code>readTreesFromNexus()</code>, <code>readTreesFromPhyloXML()</code>, and <code>readTreesFromNeXML()</code>. the <code>read()</code> function also returns an array of trees, taking flags for the input string and expected file format.</p> <p>In the below example, we parse two trees from phyloXML format, reroot them, rescale their branches randomly, and ladderise. Output is then written to newick where it could, for example, be passed to visualisation code.</p> <pre><code>    // Using two small trees here. 3 tips, all branch lengths set to 1.\n    const inPhyloXML = `&lt;phyloxml xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.phyloxml.org\" xsi:schemaLocation=\"http://www.phyloxml.org http://www.phyloxml.org/1.10/phyloxml.xsd\"&gt;\n    &lt;phylogeny rooted=\"true\"&gt;\n      &lt;clade&gt;\n          &lt;branch_length&gt;1&lt;/branch_length&gt;\n          &lt;name&gt;A&lt;/name&gt;\n      &lt;/clade&gt;\n      &lt;clade&gt;\n          &lt;branch_length&gt;1&lt;/branch_length&gt;\n          &lt;clade&gt;\n              &lt;branch_length&gt;1&lt;/branch_length&gt;\n              &lt;name&gt;B&lt;/name&gt;\n          &lt;/clade&gt;\n          &lt;clade&gt;\n              &lt;branch_length&gt;1&lt;/branch_length&gt;\n              &lt;name&gt;C&lt;/name&gt;\n          &lt;/clade&gt;\n      &lt;/clade&gt;\n    &lt;/phylogeny&gt;\n    &lt;phylogeny rooted=\"true\"&gt;\n      &lt;clade&gt;\n          &lt;branch_length&gt;1&lt;/branch_length&gt;\n          &lt;name&gt;A&lt;/name&gt;\n      &lt;/clade&gt;\n      &lt;clade&gt;\n          &lt;branch_length&gt;1&lt;/branch_length&gt;\n          &lt;clade&gt;\n              &lt;branch_length&gt;1&lt;/branch_length&gt;\n              &lt;name&gt;B&lt;/name&gt;\n          &lt;/clade&gt;\n          &lt;clade&gt;\n              &lt;branch_length&gt;1&lt;/branch_length&gt;\n              &lt;name&gt;C&lt;/name&gt;\n          &lt;/clade&gt;\n      &lt;/clade&gt;\n    &lt;/phylogeny&gt;\n    &lt;/phyloxml&gt;`;\n\n    let in = fetch('https://raw.githubusercontent.com/clockor2/phylojs/main/test/data/egTree.nwk')\n        .then(res =&gt; res.text())\n        .then(nwk =&gt; console.log(nwk))\n    // Read trees\n    //let trees = readTreesFromPhyloXML(inPhyloXML);\n\n    // Operate on trees using array methods. E.g. reroot, ladderise, and scale branch lengths randomly\n    trees.forEach(t =&gt; t.reroot(t.nodeList[4])) // arbitrarily on branch to 4th node\n    trees.forEach(t =&gt; t.ladderise())\n    trees.forEach(t =&gt; t.nodeList.forEach(\n      n =&gt; n.branchLength ? n.branchLength *= Math.floor(10*Math.random() + 1) : 0\n    ))\n\n    // write output\n    let outNewick = trees.map(t =&gt; writeNewick(t)).join('\\n')\n\n    console.log(outNewick)\n    // Returns\n    // (\"C\":1.5,(\"B\":5,\"A\":6):4.5):0.0;\n    // (\"C\":1,(\"B\":8,\"A\":16):4):0.0;\n</code></pre>"},{"location":"examples/visualise/","title":"Visualise","text":""},{"location":"examples/visualise/#visualisation","title":"Visualisation","text":"<p>This tutorial gives a minimal example of how phyojs can interface with another phylogenetics visualisation library. We parse a tree and use phylojs to reroot it randomly in a html widget. We use phylocanvas to visualise the tree. You can see the final app here.</p>"},{"location":"examples/visualise/#add-html-scaffold","title":"Add HTML scaffold","text":"<p>First, we lay down the skeleton of the html:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Passing phylojs to visualisation&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"examples/visualise/#load-libraries","title":"Load libraries","text":"<p>Next, we can include phylojs and phylocanvas via a <code>&lt;script/&gt;</code> tag in the html. This is a useful way to loading the library if one is making a relatively simple app that doesn't require much code or many html pages. For more complex apps, a more conventional installation (see installation) is probably preferable.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Passing phylojs to visualisation&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n\n    &lt;button onclick=\"onClick()\"&gt;Click to Randomly Reroot&lt;/button&gt;\n    &lt;div id=\"demo\"&gt;&lt;/div&gt;\n\n    &lt;!-- Include phylojs and phylocanvas --&gt;\n    &lt;script src=\"https://unpkg.com/@phylocanvas/phylocanvas.gl@latest/dist/bundle.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://unpkg.com/phylojs@latest/lib/dist/phylojs.min.js\"&gt;&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"examples/visualise/#add-rerooting-code","title":"Add rerooting code","text":"<p>Finally, we can add the phylojs code to parse and reroot the tree as well as the phylocanvas code to render it.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Passing phylojs to visualisation&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n\n    &lt;button onclick=\"onClick()\"&gt;Click to Randomly Reroot&lt;/button&gt;\n    &lt;div id=\"demo\"&gt;&lt;/div&gt;\n\n    &lt;!-- Include phylojs and phylocanvas --&gt;\n    &lt;script src=\"https://unpkg.com/@phylocanvas/phylocanvas.gl@latest/dist/bundle.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://unpkg.com/phylojs@latest/lib/dist/phylojs.min.js\"&gt;&lt;/script&gt;\n    &lt;!-- JS code for tree --&gt;\n    &lt;script&gt;\n        let newick = `(Bovine:0.69395,(Gibbon:0.36079,(Orangutan:0.33636,(Gorilla:0.17147,(Chimp:1.19268,Human:0.11927):0.08386):0.06124):0.15057):0.54939,Mouse:1.21460);`\n        let tree = phylojs.readNewick(newick)\n        let nNodes = tree.nodeList.length\n\n        // Initial rendering\n        const treeVis = new phylocanvas.PhylocanvasGL(\n            document.querySelector(\"#demo\"),\n            {\n                size: { width: 800, height: 600 },\n                source: phylojs.writeNewick(tree),\n                showLeafLabels: true,\n                showLabels: true\n            },\n        )\n        // Randomly reroot tree on button click\n        function onClick() {\n\n            let i = Math.floor(nNodes * Math.random() + 1) // Returns an integer from 1,...,nNodes\n            let node = tree.nodeList[i]\n\n            tree.reroot(node)\n\n            treeVis.setProps({\n                source: phylojs.writeNewick(tree)\n            })\n\n        }\n    &lt;/script&gt;\n\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>"},{"location":"examples/writer/","title":"Writing trees","text":""},{"location":"examples/writer/#write","title":"Write","text":"<p>The <code>writeNewick</code> and <code>writeNexus</code> functions are used to convert a tree data structure back into a Newick or Nexus formatted string, respectively. Both Newick and Nexus formats are commonly used in phylogenetics to represent tree data structures.</p>"},{"location":"examples/writer/#importing-the-functions","title":"Importing the functions","text":"<p>These functions are exported from a module. Import the functions to use them in your code as follows:</p> <pre><code>import { writeNewick, writeNexus } from '../src/Write';\n</code></pre>"},{"location":"examples/writer/#function-signatures","title":"Function signatures","text":"<p>The <code>writeNewick</code> function has the following signature:</p> <pre><code>writeNewick(tree: Tree, annotate: boolean = false): string\n</code></pre> <p>Parameters</p> <ul> <li><code>tree</code> (Tree): The tree object to be converted into a Newick string.</li> </ul> <p>Return</p> <ul> <li>string: A Newick formatted string representing the tree.</li> </ul> <p>The <code>writeNexus</code> function has the following signature:</p> <pre><code>writeNexus(tree: Tree, annotate: boolean = true): string\n</code></pre> <p>Parameters</p> <ul> <li><code>tree</code> (Tree): The tree object to be converted into a Nexus string.</li> </ul> <p>Return</p> <ul> <li>string: A Nexus formatted string representing the tree.</li> </ul>"},{"location":"examples/writer/#function-usage","title":"Function usage","text":"<pre><code>const tree = createTreeObject(); // Function to create the Tree object, not provided\nconst newickString = writeNewick(tree);\nconst nexusString = writeNexus(tree);\n</code></pre> <p>In the example above, <code>createTreeObject()</code> is a hypothetical function that returns a Tree object. This tree is then passed to <code>writeNewick</code> and <code>writeNexus</code> functions, which return Newick and Nexus strings respectively.</p>"},{"location":"examples/writer/#function-details","title":"Function details","text":"<p>The <code>writeNewick</code> function uses recursion to traverse the Tree object and build the corresponding Newick string. The <code>writeNexus</code> function, on the other hand, uses the same recursive traversal method, but appends additional Nexus-specific formatting to the output string.</p> <p>Both functions handle node labels, hybrid IDs, and annotations, as well as branch lengths. If a node's branch length is undefined, a default value of 0.0 is used.</p>"},{"location":"examples/writer/#function-testing","title":"Function testing","text":"<p>The module includes tests to validate both <code>writeNewick</code> and <code>writeNexus</code> functions. The tests ensure that the functions can correctly convert a Tree object back to Newick or Nexus strings.</p> <pre><code>import { writeNewick } from '../src/Write';\nimport { readNewick } from '../src/Reader';\n\ndescribe('TreeFromNewick', () =&gt; {\n  test('init', () =&gt; {\n    const inNewick = '(\"A\":1,(\"B\":1,\"C\":1):1):0.0;';\n    const tree = readNewick(inNewick);\n    const outNewick = writeNewick(tree);\n    expect(outNewick).toBe(inNewick);\n  });\n});\n</code></pre> <p>The test shown above creates a Tree object from a Newick string using the <code>readNewick</code> function. It then uses <code>writeNewick</code> to convert the tree back to a Newick string and checks if the resulting string is identical to the input string. A similar testing approach can be used for <code>writeNexus</code>.</p> <p>Please ensure that your input Tree object is correctly formed and adheres to the tree data structure standards, to avoid writing errors.</p>"}]}